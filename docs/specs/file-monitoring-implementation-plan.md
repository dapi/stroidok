# План имплементации: Мониторинг файловой системы

## Обзор
План имплементации компонента мониторинга файловой системы для отслеживания изменений в директориях и обнаружения документов для обработки.

## План имплементации

### 1. Настройка проекта и зависимостей

- [ ] 1.1 Установка зависимостей
  - [ ] 1.1.1 `github.com/fsnotify/fsnotify` - кроссплатформенный файловый вотчер
  - [ ] 1.1.2 `github.com/spf13/viper` - управление конфигурацией
  - [ ] 1.1.3 `go.uber.org/zap` - структурированное логирование
  - [ ] 1.1.4 `github.com/google/uuid` - генерация ID событий

- [ ] 1.2 Создание структуры проекта
  - [ ] 1.2.1 Создать `internal/monitoring/` директорию
  - [ ] 1.2.2 Создать `internal/monitoring/types.go` для типов и структур
  - [ ] 1.2.3 Создать `internal/monitoring/config.go` для конфигурации
  - [ ] 1.2.4 Создать `internal/monitoring/watcher.go` для основного функционала

### 2. Базовые структуры и типы

- [ ] 2.1 Определение основных типов
  - [ ] 2.1.1 Создать `FileEvent struct` с полями (Path, Type, Timestamp, Size, IsDirectory)
  - [ ] 2.1.2 Определить `EventType enum` (CREATE, MODIFY, DELETE, RENAME)
  - [ ] 2.1.3 Создать `MonitorConfig struct` с настройками мониторинга
  - [ ] 2.1.4 Определить `MonitorStatus struct` для статуса системы

- [ ] 2.2 Интерфейсы
  - [ ] 2.2.1 Создать `FileMonitor interface` с основными методами
  - [ ] 2.2.2 Создать `EventHandler interface` для обработки событий
  - [ ] 2.2.3 Создать `EventFilter interface` для фильтрации файлов

### 3. Реализация FileMonitor

- [ ] 3.1 Основная структура FileMonitor
  - [ ] 3.1.1 Создать `FileMonitor struct` с полями (watcher, processor, debouncer, config, eventChan, stopChan)
  - [ ] 3.1.2 Реализовать конструктор `NewFileMonitor(config *MonitorConfig)`
  - [ ] 3.1.3 Добавить валидацию конфигурации в конструкторе
  - [ ] 3.1.4 Реализовать методы `Start(ctx context.Context)` и `Stop()`

- [ ] 3.2 Инициализация мониторинга
  - [ ] 3.2.1 Создание fsnotify watcher
  - [ ] 3.2.2 Добавление директорий для мониторинга
  - [ ] 3.2.3 Валидация путей и прав доступа
  - [ ] 3.2.4 Обработка ошибок инициализации

- [ ] 3.3 Обработка файловых событий
  - [ ] 3.3.1 Реализовать обработчик событий fsnotify
  - [ ] 3.3.2 Конвертация fsnotify событий в FileEvent
  - [ ] 3.3.3 Фильтрация событий по типам файлов
  - [ ] 3.3.4 Отправка событий в канал для обработки

### 4. Дебаунсинг событий

- [ ] 4.1 Создание EventDebouncer
  - [ ] 4.1.1 Создать `EventDebouncer struct` с временными окнами
  - [ ] 4.1.2 Реализовать map для хранения последних событий по файлам
  - [ ] 4.1.3 Добавить таймер для очистки старых событий
  - [ ] 4.1.4 Реализовать потокобезопасность через sync.RWMutex

- [ ] 4.2 Алгоритм дебаунсинга
  - [ ] 4.2.1 Группировка множественных событий одного файла
  - [ ] 4.2.2 Временное окно 30 секунд для группировки
  - [ ] 4.2.3 Определение актуального состояния файла
  - [ ] 4.2.4 Отправка только одного итогового события

### 5. Фильтрация файлов

- [ ] 5.1 Реализация фильтров
  - [ ] 5.1.1 Создать `ExtensionFilter` для фильтрации по расширениям (.pdf, .docx, .xlsx, .txt)
  - [ ] 5.1.2 Создать `SizeFilter` для ограничения по размеру файлов
  - [ ] 5.1.3 Создать `PathFilter` для исключения путей (temp, .git, *.tmp)
  - [ ] 5.1.4 Создать `CompositeFilter` для комбинированной фильтрации

- [ ] 5.2 Конфигурация фильтров
  - [ ] 5.2.1 Добавить конфигурационные параметры для фильтров
  - [ ] 5.2.2 Реализовать загрузку паттернов из конфигурации
  - [ ] 5.2.3 Добавить валидацию паттернов
  - [ ] 5.2.4 Поддержка регулярных выражений

### 6. Рекурсивный обход директорий

- [ ] 6.1 Обработка вложенных директорий
  - [ ] 6.1.1 Рекурсивное добавление поддиректорий в watcher
  - [ ] 6.1.2 Отслеживание создания новых поддиректорий
  - [ ] 6.1.3 Обработка удаления поддиректорий
  - [ ] 6.1.4 Предотвращение циклических ссылок

- [ ] 6.2 Оптимизация обхода
  - [ ] 6.2.1 Кэширование структуры директорий
  - [ ] 6.2.2 Обработка больших деревьев директорий
  - [ ] 6.2.3 Лимитирование глубины рекурсии
  - [ ] 6.2.4 Пропуск системных и скрытых директорий

### 7. Обработка ошибок

- [ ] 7.1 Типы ошибок
  - [ ] 7.1.1 Создать кастомные типы ошибок для разных сценариев
  - [ ] 7.1.2 Реализовать `WatcherError` для ошибок файловой системы
  - [ ] 7.1.3 Создать `PermissionError` для ошибок доступа
  - [ ] 7.1.4 Добавить `ConfigurationError` для ошибок конфигурации

- [ ] 7.2 Механизмы восстановления
  - [ ] 7.2.1 Автоматическое переподключение к файловой системе
  - [ ] 7.2.2 Повторная попытка мониторинга после сбоя
  - [ ] 7.2.3 Логирование ошибок с детализацией
  - [ ] 7.2.4 Graceful degradation при частичных сбоях

### 8. Интеграция с другими компонентами

- [ ] 8.1 Взаимодействие с DocumentProcessor
  - [ ] 8.1.1 Создать интерфейс для DocumentProcessor
  - [ ] 8.1.2 Реализовать асинхронную отправку событий на обработку
  - [ ] 8.1.3 Добавить буферизацию событий
  - [ ] 8.1.4 Обработка ошибок процессора

- [ ] 8.2 Событийная архитектура
  - [ ] 8.2.1 Создать шину событий для межкомпонентного взаимодействия
  - [ ] 8.2.2 Реализовать подписчиков на события
  - [ ] 8.2.3 Добавить фильтрацию событий для подписчиков
  - [ ] 8.2.4 Реализовать метрики событий

### 9. Конфигурация

- [ ] 9.1 Структура конфигурации
  - [ ] 9.1.1 Создать YAML структуру конфигурации
  - [ ] 9.1.2 Добавить валидацию конфигурационных полей
  - [ ] 9.1.3 Реализовать значения по умолчанию
  - [ ] 9.1.4 Поддержка переменных окружения

- [ ] 9.2 Управление конфигурацией
  - [ ] 9.2.1 Загрузка конфигурации из файла
  - [ ] 9.2.2 Горячая перезагрузка конфигурации
  - [ ] 9.2.3 Валидация изменений конфигурации
  - [ ] 9.2.4 Применение изменений без перезапуска

### 10. Метрики и мониторинг

- [ ] 10.1 Сбор метрик
  - [ ] 10.1.1 Количество обработанных файлов
  - [ ] 10.1.2 Среднее время реакции на событие
  - [ ] 10.1.3 Количество ошибок мониторинга
  - [ ] 10.1.4 Размер очереди событий

- [ ] 10.2 Prometheus метрики
  - [ ] 10.2.1 Создать Counter для событий
  - [ ] 10.2.2 Создать Histogram для времени реакции
  - [ ] 10.2.3 Создать Gauge для размера очереди
  - [ ] 10.2.4 Создать Counter для ошибок

### 11. Логирование

- [ ] 11.1 Структурированное логирование
  - [ ] 11.1.1 Настройка zap логгера
  - [ ] 11.1.2 Логирование всех файловых событий
  - [ ] 11.1.3 Логирование ошибок с контекстом
  - [ ] 11.1.4 Уровни логирования для разных типов событий

- [ ] 11.2 Форматы логов
  - [ ] 11.2.1 JSON формат для продакшена
  - [ ] 11.2.2 Console формат для разработки
  - [ ] 11.2.3 Структурированные поля для метаданных
  - [ ] 11.2.4 Корреляция ID для отслеживания событий

### 12. Тестирование

- [ ] 12.1 Unit тесты
  - [ ] 12.1.1 Тестирование фильтрации файлов
  - [ ] 12.1.2 Тестирование дебаунсинга событий
  - [ ] 12.1.3 Тестирование обработки ошибок
  - [ ] 12.1.4 Тестирование валидации конфигурации

- [ ] 12.2 Integration тесты
  - [ ] 12.2.1 Тестирование на реальной файловой системе
  - [ ] 12.2.2 Тестирование с большим количеством файлов
  - [ ] 12.2.3 Тестирование восстановления после сбоев
  - [ ] 12.2.4 Тестирование кросс-платформенности

- [ ] 12.3 Тестовые утилиты
  - [ ] 12.3.1 Создание временных директорий для тестов
  - [ ] 12.3.2 Генерация тестовых файлов
  - [ ] 12.3.3 Моки для внешних зависимостей
  - [ ] 12.3.4 Benchmark тесты для производительности

### 13. Производительность и оптимизация

- [ ] 13.1 Оптимизация производительности
  - [ ] 13.1.1 Оптимизация обхода файловой системы
  - [ ] 13.1.2 Уменьшение аллокаций памяти
  - [ ] 13.1.3 Оптимизация обработки событий
  - [ ] 13.1.4 Профилирование и устранение узких мест

- [ ] 13.2 Управление ресурсами
  - [ ] 13.2.1 Контроль потребления памяти (< 50MB)
  - [ ] 13.2.2 Ограничение количества одновременных событий
  - [ ] 13.2.3 Очистка неиспользуемых ресурсов
  - [ ] 13.2.4 Мониторинг файловых дескрипторов

### 14. Graceful Shutdown

- [ ] 14.1 Корректная остановка
  - [ ] 14.1.1 Обработка сигналов ОС (SIGINT, SIGTERM)
  - [ ] 14.1.2 Завершение текущих операций
  - [ ] 14.1.3 Сохранение состояния мониторинга
  - [ ] 14.1.4 Освобождение ресурсов

- [ ] 14.2 Восстановление состояния
  - [ ] 14.2.1 Сохранение состояния перед остановкой
  - [ ] 14.2.2 Восстановление после перезапуска
  - [ ] 14.2.3 Проверка целостности состояния
  - [ ] 14.2.4 Обработка изменений за время простоя

### 15. Документация

- [ ] 15.1 Внутренняя документация
  - [ ] 15.1.1 Комментарии ко всем функциям и структурам
  - [ ] 15.1.2 Примеры использования API
  - [ ] 15.1.3 Описание архитектуры компонентов
  - [ ] 15.1.4 Руководство по отладке

- [ ] 15.2 Пользовательская документация
  - [ ] 15.2.1 Описание конфигурации
  - [ ] 15.2.2 Примеры использования
  - [ ] 15.2.3 Troubleshooting guide
  - [ ] 15.2.4 Best practices

## Приоритеты

### Высокий приоритет (Phase 1)
- Пункты 1-3: Базовая структура и основной функционал
- Пункты 4-5: Дебаунсинг и фильтрация
- Пункт 7: Обработка ошибок

### Средний приоритет (Phase 2)
- Пункты 6, 8-9: Рекурсивный обход, интеграция и конфигурация
- Пункты 10-11: Метрики и логирование
- Пункт 14: Graceful shutdown

### Низкий приоритет (Phase 3)
- Пункты 12-13: Тестирование и оптимизация производительности
- Пункт 15: Документация

## Критерии готовности

- [ ] Система отслеживает все типы файловых событий
- [ ] Фильтрация работает корректно для всех форматов
- [ ] Дебаунсинг предотвращает дублирование обработки
- [ ] Обработка ошибок надежна и автоматична
- [ ] Потребление памяти не превышает 50MB
- [ ] Время реакции на изменение файла < 5 секунд
- [ ] Поддерживается до 10 000 файлов в мониторинге
- [ ] Все тесты проходят успешно
- [ ] Документация полна и понятна